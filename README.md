# Screeps template

Template for using Rust with WASM as stack for [Screeps](https://screeps.com) game.

## Usage

Your Rust project is located in `screeps` folder. It is ready to be build with
`wasm_pack` (everything confirmed to work with version `0.10.2`):

```bash
wasm-pack build --target nodejs -- --features wee
```

Keep in mind to build it with nodejs target as it is how workaround is supposed
to work. There is additional future to be used, `wee`, enabling `wee-alloc`
allocator for smaller binaries, but it is slightly slower, so you may not want
to use it by default (in particular: for tests).

Additionally there is `js` folder which contains javascript files. I am using it
only to forward the call to my Rust `run` function, but there is nothing on the
way of using it as normal `js` rust codebase, and just use Rust as fallback.

To deploy, first aodify `tpl.screeps.json` with your credentials, and rename it
to `.screeps.json`. Remember not to commit changed `tpl.screeps.json` file, to
not leak your token! `.screeps.json` is added to `.gitignore` so it should not
be committed by accident.

Now install Grunt and required dependencies:

```
npm install
```

and run Grunt utility:

```
grunt
```

It would do all the magic to fix bindings generated by wasm-pack, and send it
to your screeps account.

Note, that solution is modifying output generated by wasm-pack, and because of
that it might happen, that it would need some fixation for newer wasm-pack version
(right now tested for `0.10.2`. If it is a case for you, read the `Workaround details`
section, so you can better understand applied approach and maybe align it yourself.

## CI/CD

Additionally this solution is prepared for github actions. All you need to make
it work, is to set two secrets for the CI:

* `SCREEPS_EMAIL` with your email connected with Screeps account
* `SCREEPS_TOKEN` with your Screeps token

The CI has three stages:

* `tests` runs basic code sanitizers - `cargo fmt` for consistent formatting,
  `cargo clippy` for linting, and `cargo test` for running UTs
* `build-wasm` builds WASM binaries and uploads them as artifacts; bindings here
  are what was build, not what is deployed! (binaries are not screeps-fixed yet)
* `deploy` fixes js bindings, and deploys everything to screeps, uploading
  deployed stuff as artifacts

`deploy` stage is executed only if both `tests` and `build-wasm` passes. The code
would be pushed to branch name matching the ref name which push triggered
the action.

The `deploy` stage has one step commented out - this is an actual deployment.
This is because I didn't set secrets for this demo repo, so it would never
pass (basically grunt crashes). To use it, make sure to have your secrets set,
and uncomment the step.

## Workaround details

The whole idea about workaround is based on fact, that
`wasm-pack build --target nodejs` produces almost working binary, with minimal
issues:

1. `TextDecoder` and `TextEncoder` are expected to sit in `util` module not existing
   Screeps ecosystem
2. Wasm binary is loaded from filesystem using `path` and `fs` modules, non of which
   exist in Screeps ecosystem

The 1st one is actually simple - it turns out, that both `TextDecoder` and
`TextEncoder` are sitting in global namespace in Screeps ecosystem. It means,
that all what is needed to fix it, is to filter out the reuires fith `util` packages.
And the 2nd one is more tricky. Basically there are lines like:

```javascript
const path = require('path').join(__dirname, 'screeps_bg.wasm');
const bytes = require('fs').readFileSync(path);
```

which need to be removed, and changed to single `require('screeps_bg')`. Also
`imports.env` setup required by Screeps is missing and shall be added.

The way I handled it is that I noticed, that whatever bindings are generated
by wasm-pack, the epilogue of the file is always the same, and it just loading
file and setting things up. The whole trick, is to remove last nine lines of it,
and substitute them with something like:

```javascript
const bytes = require("screeps_bg");
const wasmModule = new WebAssembly.Module(bytes);

imports.env = {
    memoryBase: 0,
    tableBase: 0,
    memory: new WebAssembly.Memory({ initial: 256 }),
    table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })
};

const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm = wasmInstance.exports;
module.exports.__wasm = wasm;`;
```

I hardcoded `screeps_bg` but it probably can be retrievied with some tricks
from line:

```javascript
const path = require('path').join(__dirname, 'screeps_bg.wasm');
```

However my point here is, that for my project structure hardcoding it does
not harm me, but going into details of how things are generated may make
alignment for other wasm-pack versions easier (unless some serious changes
occurs, at worst case it should be aligned lines count to ignore).

All the filtering and substitution is handled in `Gruntfile.js` in `copy`
step with `process` utility.

Note that I made sure, that the `Gruntfile` is configured by env instead
of cmd lines args. It is beacuse of CI security (impossible to leak secrets
just by looking on command line execution). It makes configuration of it
easy for most CIs. I deliveret solution for github actions, because they
have secrets for free - it turns out, that for gitlab they are available only
on premium so deployment seems to leak secrets. After all configuring it for
any other CI should be easy.
